# load general packages and functions
import torch
from rdkit.Chem import MolFromSmiles, QED, Crippen, Descriptors, rdMolDescriptors, AllChem
import numpy as np
from rdkit import DataStructs
from rdkit import Chem
import subprocess
import csv
# load program-specific functions
from parameters.constants import constants as C
from score_util import calc_SC_RDKit_score
from rdkit.Chem import rdMolAlign
import sascorer

def compute_score(graphs, termination_tensor, validity_tensor, uniqueness_tensor, smiles, jak3_model):

    if C.score_type == "reduce":
        # Reduce size
        n_nodes = graphs[2]
        n_graphs = len(n_nodes)
        max_nodes = C.max_n_nodes
        score = torch.ones(n_graphs, device="cuda") - torch.abs(n_nodes - 10.) / (max_nodes - 10 + 1)
    
    elif C.score_type == "augment":
        # Augment size
        n_nodes = graphs[2].float()
        n_graphs = len(n_nodes)
        max_nodes = C.max_n_nodes
        score = torch.ones(n_graphs, device="cuda") - torch.abs(n_nodes - 40.) / (max_nodes - 40)
        
    
    elif C.score_type == "qed":
        # QED
        score = [QED.qed(MolFromSmiles(smi)) for smi in smiles]
        score = torch.tensor(score, device="cuda")


    elif C.score_type == "activity":
        n_mols = len(smiles)

        mols = [MolFromSmiles(smi) for smi in smiles]

        # QED
        qed = [QED.qed(mol) for mol in mols]
        qed = torch.tensor(qed, device="cuda")
        qedMask = torch.where(qed > 0.5, torch.ones(n_mols, device="cuda", dtype=torch.uint8), torch.zeros(n_mols, device="cuda", dtype=torch.uint8))
        
        activity = compute_activity(mols, jak3_model)
        activityMask = torch.where(activity > 0.5, torch.ones(n_mols, device="cuda", dtype=torch.uint8), torch.zeros(n_mols, device="cuda", dtype=torch.uint8))


        score = qedMask*activityMask
    
    elif C.score_type == '3D_SMI':
        ref = ''
        n_mols = len(smiles)

        ref_mol = Chem.MolFromSmiles(ref)
        ref_mol = Chem.AddHs(ref_mol)
        Chem.AllChem.EmbedMolecule(ref_mol, randomSeed=10)
        Chem.AllChem.UFFOptimizeMolecule(ref_mol)

        # gtruth_structure is the godden structure, smile is generated by agent
        score_list = []
        for smile in smiles:
            gen_mol = Chem.MolFromSmiles(smile)           
            try:
                gen_mol = Chem.AddHs(gen_mol)
                
                Chem.AllChem.EmbedMolecule(gen_mol, randomSeed=10)
                Chem.AllChem.UFFOptimizeMolecule(gen_mol)
                
                pyO3A = rdMolAlign.GetO3A(gen_mol, ref_mol).Align()
                
                score_l = calc_SC_RDKit_score(gen_mol, ref_mol)
                score_list.append(score_l)
               
            except Exception:
                score_l =0
                score_list.append(score_l)
        score = torch.tensor(score_list, device="cuda")

    elif C.score_type == 'SA':
        
        score_list =[]
        for smile in smiles:
        # gtruth_structure is the godden structure, smile is generated by agent
            mol = Chem.MolFromSmiles(smile)
            try:
                if mol:
                    sa_score = sascorer.calculateScore(mol)
                    score_list.append(sa_score)
                else:
                    score_list.append(0)
            except:
                score_list.append(0)
        score = torch.tensor(score_list, device="cuda")
    
    elif C.score_type == 'logp':

        
        w = 2.5
        goal_ClogP = w

        score_list =[]
        for smile in smiles:
            # gtruth_structure is the godden structure, smile is generated by agent
            mol = Chem.MolFromSmiles(smile)
            if mol:
                mol_ClogP = Chem.Crippen.MolLogP(mol)
                Rclogp = max(0.0, 1 - (1/6)*abs(mol_ClogP - goal_ClogP))
                score_list.append(Rclogp)
            else:
                score_list.append(0)
            score_list.append(0)
        score = torch.tensor(score_list, device="cuda")
    
    elif C.score_type == '3DSMI_tanimoto':
        """3d similary with 2d tanimoto"""

            
        ref = ''
        ref_mol = Chem.MolFromSmiles(ref)
        query_fp = AllChem.GetMorganFingerprint(ref_mol, 2, useCounts=True, useFeatures=True)
        ref_mol = Chem.AddHs(ref_mol)
        Chem.AllChem.EmbedMolecule(ref_mol, randomSeed=10)
        Chem.AllChem.UFFOptimizeMolecule(ref_mol)
        score_list = []

        for smile in smiles:

        # gtruth_structure is the godden structure, smile is generated by agent
            gen_mol = Chem.MolFromSmiles(smile)
            if gen_mol is None:
                score_list.append(0)
        
        
            try:
                fp = AllChem.GetMorganFingerprint(gen_mol, 2, useCounts=True, useFeatures=True)
                score_tanimoto = DataStructs.TanimotoSimilarity(query_fp, fp)
                gen_mol = Chem.AddHs(gen_mol)
                Chem.AllChem.EmbedMolecule(gen_mol, randomSeed=10)
                Chem.AllChem.UFFOptimizeMolecule(gen_mol)
                pyO3A = rdMolAlign.GetO3A(gen_mol, ref_mol).Align()
                score_l = calc_SC_RDKit_score(gen_mol, ref_mol)/(0.1+score_tanimoto)
                score_list.append(score_l)
            except Exception:
                score_list.append(score_l)
        score = torch.tensor(score_list, device='cuda')
    
    elif C.score_type == 'tanimoto':
        """2d similarity"""
        score_list = []

    
        k = 0.8
        query_structure = ""
        
        
        query_mol = Chem.MolFromSmiles(query_structure)
        query_fp = AllChem.GetMorganFingerprint(query_mol, 2, useCounts=True, useFeatures=True)            
        for smile in smiles:
            mol = Chem.MolFromSmiles(smile)
            if mol is None:
                score_list.append(0)
            
            
            fp = AllChem.GetMorganFingerprint(mol, 2, useCounts=True, useFeatures=True)
            score = DataStructs.TanimotoSimilarity(query_fp, fp)
            score_l = min(score, k) / k
            score_list.append(float(score_l))
        score = torch.tensor(score_list,device='cuda')
    
    elif C.score_type == 'M_SIM_QED':
    # Multi-objective optimization
    # Scores structures based on Tanimoto similarity to a query structure.
    #    Scores are only scaled up to k=(0,1), after which no more reward is given.
    #    score = w * SIM(s) + (1-w) * QED(s)
    

        score_list = []
        ref = ''
        w = 0.0
        
        query_mol = Chem.MolFromSmiles(ref)
        query_fp = AllChem.GetMorganFingerprint(query_mol, 2, useCounts=True, useFeatures=True)
        # gtruth_structure is the godden structure, smile is generated by agent
        for smile in smiles:
            mol = Chem.MolFromSmiles(smile)
            if mol is None:
                score_list.append(0)
                

            
            else:
                qed_score = QED.qed(mol)
                fp = AllChem.GetMorganFingerprint(mol, 2, useCounts=True, useFeatures=True)
                tanimoto_score = DataStructs.TanimotoSimilarity(query_fp, fp)
                score = w*tanimoto_score + (1-w)*qed_score
                score_list.append(float(score))
        score = torch.tensor(score_list,device='cuda')


    elif C.score_type == 'docking_score':

    #based on dock stream and Schrodinger, you must define your config file 
        smi_filename = 'test_smi.smi'
        f = open(smi_filename,'w')
        for i in smiles:
            f.write(i+'\n')
        f.close()

        command = 'python docker.py -conf /Glide_docking_graphinvent.json -print_scores'
        subprocess.run(command,
                        check=True,  # force python to raise exception if anything goes wrong
                        universal_newlines=True,  # convert output to string (instead of byte array)
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        shell=True)
        score_csv_path = '<your path>/Glide_scores.csv'
        with open(score_csv_path, 'r') as csvfile:
            reader = csv.DictReader(csvfile)
            reader2 = csv.DictReader(csvfile)
            docking_score = [float(row['score']) for row in reader]
            ligand_id = [row2['ligand_number'] for row2 in reader2]
            print('ligand_id',ligand_id)
            a = dict(zip(ligand_id, docking_score))
            print('dict_a',a)
        docking_score.sort(reverse = False)
        score = torch.tensor(docking_score[:len(smiles)],device='cuda')
        



            

        

    
            



    else:
        raise NotImplementedError("The score type chosen is not defined. Please choose among 'reduce', 'augment', 'qed' and 'activity'.")
    
    # remove non unique molecules from the score
    score = score * uniqueness_tensor

    # remove invalid molecules
    score = score * validity_tensor

    # remove non properly terminated molecules
    score = score * termination_tensor

    return score


def compute_activity(mols, jak3_model):

    n_mols = len(mols)

    activity = torch.zeros(n_mols, device="cuda")

    for idx, mol in enumerate(mols):
        fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)   
        ecfp4 = np.zeros((2048,))                                       
        DataStructs.ConvertToNumpyArray(fp, ecfp4)
        activity[idx] = jak3_model.predict_proba([ecfp4])[0][1]
    
    return activity

        
def compute_activity_score(graphs, termination_tensor, validity_tensor, uniqueness_tensor, smiles):
    
    n_mols = len(smiles)

    mols = [MolFromSmiles(smi) for smi in smiles]

    # QED
    qed = [QED.qed(mol) for mol in mols]
    qed = torch.tensor(qed, device="cuda")
    qedMask = torch.where(qed > 0.5, torch.ones(n_mols, device="cuda", dtype=torch.uint8), torch.zeros(n_mols, device="cuda", dtype=torch.uint8))
    
    activity = compute_activity(mols)
    activityMask = torch.where(activity > 0.5, torch.ones(n_mols, device="cuda", dtype=torch.uint8), torch.zeros(n_mols, device="cuda", dtype=torch.uint8))


    score = qedMask*activityMask

    # remove non unique molecules from the score
    score = score * uniqueness_tensor

    # remove invalid molecules
    score = score * validity_tensor

    # remove non properly terminated molecules
    score = score * termination_tensor

    return score
    